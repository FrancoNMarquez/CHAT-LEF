 Titulo: Clase17 (parte 1) Curso Inteligencia Artificial 
 URL https://youtu.be/1rBuE0-juks  
 1773 segundos de duracion 
 Hola bienvenidos al curso de Inteligencia artificial de ifes Los invito a empezar con nuestra clase número 17 [Música] Hola a todos Bienvenidos a la clase número 17 del curso de Inteligencia artificial de ifes seguimos en el módulo de Deep learning y vamos a ver un nuevo tema justamente Deep learning que son las redes neuronales convolucionales la clase pasada empezamos a ver nuestra primera red neuronal justamente programandola con python en el ámbito de cola en el cual vimos primero Un ejemplo muy sencillo y luego un ejemplo un poco más complejo en el cual tratábamos imágenes de un Data set que llamaba Fashion Eminem en esa última red neuronal tratábamos de dilucidar en un problema de clasificación si una imagen que entraba a esa red era un determinado tipo de prenda o de calzado u otro con esa red logramos buenos objetivos Tuvimos una buena precisión y realmente con las pruebas que hicimos logramos en todos los casos por ejemplo tomando el ejemplo de la bota poder dar que la imagen que entraba representaba una bota pero en la vida real las imágenes no siempre van a venir como están preparadas en ese conjunto de datos dado que las imágenes probablemente no sean exactamente iguales Ni estén ubicadas en la misma posición en todos los casos ese zapato está ubicado en una misma posición y representaba una idea estéticamente similar bueno Esto no va a pasar siempre Por ende es que las redes neuronales convolucionales implican una evolución en el tratamiento de las imágenes y el reconocimiento de las mismas a través de características o patrones que forman parte de un conjunto de imágenes es por ello que ahora yendo al colap vamos a empezar a hablar de este tipo de redes y vamos a lograr justamente implementar al igual que en la clase pasada un problema sencillo y en la segunda parte de la clase un problema más complejo vamos con ello Bueno aquí estamos en el cola 17-1 que es el que corresponde a la primera parte de esta clase en donde se hace un abordaje teórico de lo que deseamos recién en la introducción de esta clase básicamente las limitaciones que tiene la red que diseñamos en la clase anterior en cuanto al reconocimiento de imágenes que son muy avanzadas acá tenemos un pullover y acá tenemos una bota que es lo que usamos como ejemplo en la clase anterior cuál es el problema aquí supongamos que yo quisiera comparar esta bota con otra imagen de entrada que fuese esto evidentemente Esta imagen más allá de que tiene una calidad diferente porque tiene una definición que no es de 28 por 28 aún así yo llevase esta imagen a una definición de 28 por 28 esta representación y todas las otras con las cual la red se entrenó Y a partir de eso identifica que cualquier cosa que se parezca a Esto va a ser clasificado como una bota Esto va a ser muy diferente y difícilmente ocurre la misma suerte dado Que obviamente las perspectiva en que está mostrada está gota es radicalmente diferente esto más allá insisto de la cantidad de píxeles que tenga como definido Entonces esto es un simple ejemplo y esto se puede llevar a cualquier otra cuestión como puede ser el pullover o el resto de los componentes que forman parte de El Data set Eminem y correr la misma suerte con lo cual Es evidente que esta red que hicimos la clase pasada para la identificación de imágenes tiene serias limitaciones es por ello que para tratar de tener una versión más avanzada de red neuronal que pueda trabajar con imágenes se crearon las redes neuronales convolucionales esta redes neuronales trabajan con dos conceptos fundamentales que son las convulsiones y los publiques o agrupaciones Pero antes de avanzar con la descripción de la estructura de este tipo de red vamos a poner un ejemplo de cómo trabaja el concepto de red neuronales convolucionales desde lo conceptual después vamos básicamente a lo estructural supongamos que queremos una red neuronal que pueda reconocer en una imagen si algo que se está visualizando en ella eso no un rostro bien lo que queremos es una red que no Determine a partir de todo un conjunto sí como un todo si algo es o no un rostro a partir de como hicimos en la red neuronal de la clase pasada ponemos un montón de rostros y detecte un patrón con ello sino que ese patrón esté establecido a partir de un conjunto de características que tiene eso que conforma un rostro por ejemplo empezar a detectar si hay ojos si en nariz lleven la boca etcétera etcétera es decir si todo ese conjunto de elementos determina que eso es un rostro la determinación de ese conjunto de elementos si va a ser a partir de características es decir yo voy a determinar que para que algo sea reconocido como rostro tiene que tener un montón de características que lo que dijimos recién algo que tenga una forma de ojo otra cosa que tenga una forma de nariz otra cosa que tenga una forma de boca y cada una de esas características cuando es imagen pase por toda esa características y tenga una devolución positiva reconociendo que esas características están en esa imagen pues Entonces será determinado que eso es un rol Así trabajan las redes neuronales convolucionales aquí tenemos un gráfico que lo vamos a ir tomando como referencia en cada uno de los pasos que tengamos en esta clase en primer lugar Tenemos aquí la imagen natural si la cual va a ser pasada por un proceso de convolución Qué es una convolución una convolución como dice su definición aquí es un filtro que pasa sobre una imagen la procesa y extrae características que muestran una similitud en la imagen Es decir si vamos a gráfico de aquí aquí tengo la imagen original y le aplicó un filtro que es esto que está aquí en Amarillo a partir de eso género un mapa de características así se llama el conjunto de características que a través de distintos filtros yo extraigo de una imagen con la que voy a entrenar a la red con lo cual esta característica representan esto que hablamos recién de el caso del rostro y los componentes del rostro y tengo aquí una muestra obviamente solamente de cuatro características se trabajan con mucha más características obviamente simplemente Porque queremos simplificar para que este gráfico se vea bien Vamos a ver aquí una cuestión que es importante que tiene que ver con las dimensiones de lo que entra las dimensiones del filtro y la dimensiones de lo que sale luego de la coagulación para eso vamos a un ejemplo primero de explicar cómo se aplica a través de un ejemplo muy sencillo cómo sería una convolución aquí tenemos un ejemplo supongamos que estos 9 píxeles son parte de una imagen obviamente pensamos en una imagen de tono de grises y por eso cada Pixel está representado por un número que va de 0 a 255 como ya vimos en el caso de los Data set Eminem y Fashions bien cada uno de estos números que está justamente a propósito con un tono de gris representa un píxel lo que voy a hacer con este Pixel es aplicar un filtro el filtro es esto que está aquí en Amarillo menos 101 menos 202 menos 1 0 1 obviamente Este es un ejemplo muy sencillo pero los filtros los va a determinar automáticamente la red neuronal convolucional en este caso estamos tomando un ejemplo de un filtro del 3x3 muy usado digamos en las redes en general y lo que hace aquí justamente es aplicar una cuenta que la realiza multiplicando cada uno de los valores de los filtros por su correspondiente en posición de El Pixel que tomamos como ejemplo así de este modo multiplicamos 0 por -1 64 por 0 128 por 1 tal como tengo la cuenta aquí al costado y justamente cada una de estas nueve multiplicaciones las voy a sumar y el resultado me va a dar un número ese número que yo obtenga 86 en este caso va a ser el que va a reemplazar al 192 original este proceso se va a repetir por casi todos los píxeles de una imagen y ya vamos a ver porque decimos por casi todos y justamente va a hacer que todos los valores vayan teniendo un nuevo valor a partir de que se aplicó ese filtro ese filtro una vez que pase por toda la imagen va a ir generando paso a paso un mapa de características luego otro filtro hará lo propio recorrerá la imagen y generará otro componente de todo este conjunto de mapas de características a diferencia del caso que vimos aquí de un filtro de tres por tres aquí tenemos un filtro de 9 * 9 y he generado a partir de imágenes 36 por 36 4 mapas de características obviamente a través de cuatro filtros de 9 x 9 de 28 por 28 para ver un ejemplo de esto y que sea lo más gráfico y animado posible le he dejado aquí una URL que apunta a una animación vamos a hacer clic y la vamos a ver aquí tenemos el filtro donde en esta animación que está muy interesante van a ver que en este caso con centro en el 7 apk el filtro y en la misma posición Ha logrado un 9 aquí está la cuenta no que pueden ir siguiendo paso a paso luego hace lo propio y genera un nuevo valor en reemplazo del 6 que es el 8 y bueno ahora acelera la animación y van viendo que al recorrer el filtro toda la imagen va generando un nuevo valor para cada uno de los pasos de esto que está aquí que es el mapa de características bueno esta animación la pueden ver Tantas veces como quieran a quitar a cuenta que también es muy interesante para que se entienda la lógica que no es muy compleja Pero bueno aquí vuelve a aplicar un filtro tres por tres como el ejemplo que tomamos nosotros a diferencia de el gráfico que tenía un filtro a 9 por 9 y ahora vamos a ver un poco algo relacionado con la importancia de la determinación del tamaño del filtro bien Ahora veamos lo siguiente Porque si tengo una imagen de 36 por 36 el mapa de características es de 28 por 28 bien la razón es el tamaño del karland o del filtro Sí el filtro también se le llama kernel en este caso fíjense lo siguiente si yo tengo un canal de 9 por 9 ese carnet tiene que estar aplicado en una situación en la cual el centro tiene que tener de 9 por 9 4 vecinos a la izquierda cuatro vecinos a la derecha cuatro vecinos arriba y cuatro vecinos abajo justamente porque es de 9 por 9 Por ende ese filtro nunca se puede aplicar a otro elemento que esté en la imagen que no tenga esa cantidad de vecinos por ejemplo no podría ser el 00 la posición cero cero porque no tiene vecinos tiene cuatro abajo cuatro a la derecha pero no tiene arriba ni a la izquierda entonces Esto hace que yo deba dejar cuatro filas arriba cuatro filas abajo cuatro columnas a la derecha y cuatro columnas a la izquierda pasando en consecuencia de una estructura de 36 x 36 a una estructura de 28 por 28 como tienen cada uno de los mapas de características generados por este filtro de 9 x 9 ahora para hacer un código que también nos permita entender esto desde algo que sea lo más visual posible dado que después empezamos con las redes neuronales y toda esta cuestión obviamente va a quedar muy oculta en justamente las capas ocultas es que tenemos una práctica simulativa con python de Cómo aplicar filtros en una imagen que tomamos como ejemplo la imagen que tomamos como ejemplo la importamos desde una librería que se llama sai pay y justamente a través de Miss tomamos lo que es una escalera Sí una imagen de una escalera por eso se llama ascent Sí y justamente empiezo por con mapley plt haciendo un ploteo básicamente de cada uno de los componentes de la imagen y me da la resultante que es esto que veo aquí bien luego lo que vamos a hacer es tomar una copia de esa imagen generando una variable que se llama img Transformers y vamos a tomar a través del método shape el 0 y el 1 Cuáles son las dimensiones de esa imagen si los sites y me da que el size es 512 por 512 bien Luego hacemos un código a través del cual vamos a generar una matriz de tres por tres que es Ni más ni menos que el filtro y luego en este código hacemos un Ford donde vamos a recorrer todos los puntos de esta imagen de aquí sí decir cada uno de los X y los y de esta imagen que está aquí evitando como dice aquí los bordes por eso arranca de uno y no de Cero y llega a 6 menos 1 si al ser de 3 por 3 lo que estoy dejando como vecino a diferencia del caso 9 por 9 es solamente uno uno arriba uno abajo uno izquierdo en la derecha y recorro los X dentro de los X recorros y en cada uno de estos casos lo que hago es generar una cuenta similar una cuenta acumulativa similar a la que hicimos aquí Este ejemplo y vimos también en la animación fíjense que lo que hago Ni más ni menos es multiplicar el filter 0 0 el filtro 01 el filtro 02 es decir cada uno de los elementos de este filtro menos uno el menos dos el menos uno el cero el cero cero el uno el dos y el 1 y multiplicarlo por cada uno de los píxeles de cada una de las partes de esa imagen Y obtener un nuevo Pixel y ese nuevo Pixel lo voy a poner en el mapa de características que lo que estoy haciendo aquí es decir en cada xy que tomaba de antes Ahora hay un nuevo x y por eso la salida es img Transformers que es la imagen original y poniéndole convolución que convolution convolution es el resultado de esta cuenta fíjense que es importante aquí lo que estoy poniendo esta parte de aquí la suma me puede llegar a dar más que 255 mucho cuidado con esto el filtro puede dar un valor Superior y sabemos que si pongo un valor superior 255 no va a representar ningún color y me va a dar un error Por ende trata de evitar de que el valor no sea mayor que 255 o algo muy importante que sea negativo también puede pasar que sea menor que cero por eso este If de acá es importante finalmente hacemos la impresión y vemos que el gráfico sí que en este caso no es una imagen como la original sino ya es un mapa de características resalta de alguna manera todas las líneas verticales Sí si pueden comparar la imagen original Ya ven que tiene una distorsión respecto de la imagen original porque ya no se trata de una imagen se trata de un filtro Entonces en este filtro lo que destaca es eso luego aplicó otro filtro y este que está aquí y hago exactamente la misma lógica que recién y me da otro mapa de características y luego hacemos uno más con otro filtro y tengo otro mapa con lo cual ustedes pueden variar este filtro con los números que quieran y justamente ver de alguna manera interesante Cuál es la resultante la imagen resultante simplemente aplicando este código y variando el valor del filtro que van a elegir en este caso primero después ese luego este otro que está destacado aquí y en este tercer caso este otro habiendo entendido de qué se trata el concepto de convolución es momento ahora de ver de qué trata el concepto de bullying Bueno vamos aquí a la imagen tenemos Entonces estos cuatro mapas de características producto de la convolución le aplicamos un proceso de pulin y pasamos estos cuatro mapas de características a cuatro mapas pero del tamaño 28 por 28 a un tamaño de 14 por 14 Qué hizo el bullying acá hizo una compactación una reducción de la dimensionalidad concepto que hablamos mucho en la parte de Machine learning siempre con el concepto que también dijimos en aquellas clases de no perder calidad de información es decir tratar hacer una transformación en donde reduzco la dimensión fíjense que en este caso a la mitad pero tratando justamente de mantener las características principales de esto que insisto no es una imagen sino un mapa de características ahora tenemos Entonces esta pregunta que está de alguna manera tiene una definición que respalda lo que explicábamos recién resulta que no existe una sola forma de hacer bullying hay varios métodos para hacer pulin nosotros vamos a usar uno de ellos que es el Max y justamente Aquí está una explicación que de una manera siempre gráfica intenta explicar De qué trata esto vamos a suponer que yo tengo aquí este conjunto de píxeles sí de cuatro píxeles por 4 píxeles sí lo que vamos a hacer en este caso es dividir este conjunto de 4x4 en cuatro conjuntos de dos por dos Ven aquí tengo el primero que lo he puesto aquí arriba el segundo aquí el tercero aquí el cuarto aquí qué voy a hacer con cada uno de estos casos voy a determinar Cuál de estos cuatro valores es el máximo y lo voy a seleccionar Lo mismo hago con el otro lo mismo hago con el otro lo mismo hago con el otro con lo cual con estos cuatro voy a conformar en la misma posición en que estaba ese Cuarteto es decir 92 corresponde a este Cuarteto que estaba en este vértice superior izquierdo lo voy a poner aquí luego el 128 aquí el 255 aquí y el 168 aquí de esta manera hemos hecho una reducción de la dimensionalidad porque pasamos de una matriz de 4x4 a una matriz de 2 por 2 haciendo una reducción del 50% al igual que como teníamos en el gráfico de aquí arriba donde pasábamos de una figura de 28 por 28 a una figura de 14 por 14 este proceso se va a repetir en distintas capas acá tenemos una capa oculta es la única capa oculta que tiene una red neuronal convolucional puede tener muchas en este ejemplo tiene dos y el proceso va a ir creciendo justamente en la reducción es decir luego de la primer capa oculta que está conformada por un proceso de convolución y un proceso de pulin va a haber una nueva una capa oculta en la cual el input van a ser estos cuatro mapas de características que han sido pasado por el proceso de pullying bien nuevamente yo voy a pasar de 14 a un grupo de diez por diez por qué porque vuelvo a perder cuatro características como el primer caso de arriba de abajo de la izquierda de la derecha conformando en este caso un grupo de más mapas de características Esto es algo que habitualmente se hace de manera creciente es decir pase de cuatro mapas a 8 mapas porque porque aprovecho que como se reduce la dimensionalidad yo puedo tener más mapas sin ocupar más espacio con ellos porque ahora yo tengo mapas más chicos pasé de mapas de 28 por 28 a mapa de 10 por 10 si sacan la cuenta van a ver que aún teniendo más mapas tengo un consumo de espacio menor y luego vuelvo a aplicar un proceso de bullying pasando en este caso como antes de 28 por 28 a 14 por 14 en este caso de 10 por 10 a 5 por 5 finalmente esto se repite tantas capas ocultas como yo haya determinado y termina en una layer donde tengo todas las salidas propias de una capa densa parecida a la que hicimos justamente en nuestra red neuronal artificial que la primera que hicimos y que me van a llevar a en este caso supongamos cuatro valores posibles de salida o los que haya que tener como consecuencia o características del ejemplo que estoy tomando yo para aplicar en este caso Este modelo de red neuronal convolución habiendo abordado todos los conceptos teóricos relativos a una red neuronal convolucional es que vamos ahora a empezar a programar como dice título aquí nuestra primera red neuronal convolucional lo primero que hacemos Es importar nuestra ya conocida librería de tensorflow y crear la variable de menist justamente con los datos del dataset que ya conocemos también Fashion luego creamos los conjuntos de entrenamiento y test como lo hicimos también la clase pasada y aquí tenemos el primer elemento que cambia respecto de lo que veníamos trabajando antes me refiero al reformateo de las imágenes del conjunto de entrenamiento y las imágenes del conjunto de Test en ambos casos a través del método de rehave y le especificamos cuatro parámetros el primero de ellos es la cantidad de observaciones 60.000 el primer caso 10.000 en el segundo como ya conocemos luego como ya también conocemos las dimensiones de ancho y alto 28 por 28 en ambos casos y el último parámetro especifica la cantidad de canales de colores es decir cuando tenemos tonos de gris como en este caso el parámetro se fija en uno cuando tenemos colores de rgb es decir que son los tres colores primarios rojo verde y azul el canal de especificarse con el número 3 luego lo que tenemos que hacer también para ambos conjuntos es normalizar los valores que corresponden Al conjunto de entrenamiento y Al conjunto de Test simplemente como ya hemos explicado en otras oportunidades dada la característica que tienen los números que son propios de los canales de grises que van de 0 a 255 lo que hacemos Es dividir ese valor por 255 justamente Entonces de esa manera yo tengo valores que en lugar de ir de 0 255 van a ir de 0 a 1 y finalmente la creación del modelo el modelo lo vamos a crear consecuencia el model keras de tensorflow igualandolo a una variable que le vamos a poner model igual que como hicimos Nuestra primer red neuronal la clase pasada vamos a poner dentro de esta estructura dos capas de tipo convolucionales y dos capas de tipo pulin es decir vamos a tener dos parejas así como funcionan en este caso voy a no puede ir una convolucional sin su respectiva pulin en este caso tenemos las primeras aquí y la segunda es aquí luego el resto ya vamos a volver a esa parte luego el resto va a ser Exactamente igual a lo que hicimos la última clase pero que sólo definimos como una red neuronal artificial común sí o densa como se llama en estos casos tengo una capa fluten como tenía en aquella oportunidad tengo una capa densa oculta y tengo una capa de salida también densa si la capa flaten la capa densa va a tener 128 neuronas y la capa de salida también densa va a tener 10 neuronas porque justamente son 10 los valores posibles como ya sabemos los 10 tipos de prenda que tiene el modelo fashion emmy volviendo al tema propio de lo que estamos agregando o codificando por primera vez en relación a esta red neuronal convolucional tenemos la primer Capa convolucional en la cual definimos en principio 32 mapas de características elegimos un filtro de tres por tres elegimos una función de activación relu y le definimos dado que la entrada es en este caso es la primer capa de convolución pero a su vez es la entrada del modelo Cuál es la el formato que va a tener la imagen que va a entrar que justamente es de 28 por 28 con el 1 que como dijimos recién le especifica que es una imagen con tonos de grises luego viene la capa de bullying que utiliza una reducción de 2 por 2 con lo cual va a reducir como el ejemplo que vimos en la teoría a la mitad la dimensión del mapa de características que va a lograr esta otra capa anterior y luego la segunda el segundo par de capas una convulsional y su Bull de nuevo tenemos relu no ponemos impulsar porque obviamente Esta no es de entrada definimos un filtro de tres por tres pero aumentamos la cantidad de mapa de características de 32 a 64 la duplicamos la cantidad de mapas Y al igual que lo que hicimos o lo que vimos en el dibujo en la teoría así esto insisto no es ninguna regla se puede trabajar del modo que ustedes les parezca mejor o más conveniente y luego nuevamente otra capa de bullying con el mismo criterio que el anterior con una reducción de dos por dos y finalmente lo que hablamos antes estas tres capas que se parecen completamente a lo que era por sí sola la primera red neuronal que hicimos en la clase pasada luego con pilor modelo uso nuevamente el optimizador Adam uso esta función de pérdida y le pido que por favor me registre el akiu Brasil con el cual voy a medir la eficiencia del modelo Finalmente y luego aplicó el método submari del model que me da una información muy valiosa o muy digamos este interesante para poder visualizar que es toda la descripción del modelo que Acabo de crear donde me Indica cuáles son las capas que lo que yo había antes y la convolucional primera la Pull en primera la conversión segunda y segunda después la flaten y las dos dedos es decir está la capa de entrada perdón y es la capa de salida en el medio tenemos algunos detalles que son importantes que ustedes vean la imagen que entra Es de 28 por 28 pero ya me muestra aquí en la primer capa convolucional que la dimensión que va a tomar va a ser de 26 por 26 porque porque hacer como vimos antes el filtro de tres por tres le saca un este una fila al principio una fila al final una columna derecha y una columna izquierda con lo cual hay una reducción que tiene que ver con el no usar como dijimos antes los píxeles de los vértices porque no se los puede filtrar luego se aplica la primera capa de bullying en la cual se reducen la dimensión de 26 por 26 a 13 por 13 a continuación la segunda capa de convolución que pasa de 13 a 11 por el mismo motivo que pasó de 28 a 26 porque se quitan los valores de los extremos y la capa de public reduce sus once fíjese a 5 Es decir aquí la mitad literal no puede existir porque es un número impar con lo cual redondea hacia abajo y justamente la dimensión que queda es 5 por 5 no 5,5 por 5,5 queda totalmente imposible y luego viene la capa flaten que tiene 1600 neuronas porque porque toma la salida de esta capa que tiene 5 por 5 por 64 da esta dimensión Y luego como dijimos antes la capa densa de 128 y la capa de salida de 10 que omití acá un detalle importante cuando mostra el modelo que seguramente ustedes lo habrán visto que la función de activación para la salida es softmax acuérdense que como vimos en la teoría es softmax y son en más de dos salidas posibles y si no sería de tipo logística o sigmoide habrán observado una columna aquí que dice paran y son la cantidad de parámetros que maneja cada una de las capas fíjense que si quieren entender De dónde sale este número Yo aquí les he dejado un comentario justamente debajo del sumar y para que entiendan Cuál es la forma de cálculo que aplican cada caso para entender porque muestra cada uno de estos parámetros y al final muestra el total de parámetros que no es Ni más ni menos que la suma de toda esta columna y para terminar entrenamos el modelo y hacemos la evaluación de la función de pérdida con lo cual es un entrenamiento muy cortito de sólo cinco épocas y llegamos a una 092 y la función de pérdida me lleva a una pérdida final de 0 19 71 habiendo partido de 0.45 17 en la evaluación del conjunto de Test me lleva a 0 90 52 que son buenos aquí así entiendan siempre que para una cantidad de pochos muy atípica porque en realidad debería haber hecho un entrenamiento de por lo menos 100 épocas Bueno hasta aquí terminamos esta primer parte de la clase quedamos para aplicar entonces en la segunda parte de la clase un ejemplo también de red neuronal convolucional pero con una propósito o un ejemplo un poco más avanzado nos vemos en la segunda parte aquí terminamos con la primera parte de esta clase nos vemos en la segunda parte [Música]
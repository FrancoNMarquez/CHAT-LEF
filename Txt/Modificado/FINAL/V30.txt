 Titulo: Clase16 (parte 1) Curso Inteligencia Artificial 
 URL https://youtu.be/NJKUPY31Ihw  
 852 segundos de duracion 
 Hola bienvenidos al curso de Inteligencia artificial de ifes Los invito a empezar con nuestra clase número 16  Hola a todos Bienvenidos a la clase número 16 del curso de Inteligencia artificial de ifes seguimos en el módulo de Deep learning tercera clase de este módulo y luego de Dos clases teóricas muy importantes vamos a empezar con la práctica a programar Nuestra primer red neuronal les recuerdo la necesidad de que las dos clases anteriores las hayan visto bien porque es muy importante que tengan muy presentes esos conceptos para justamente aplicarlos no solamente en esta clase sino en todo lo que venga de ahora en más así que sin más palabras pasamos al cola para programar Nuestra primer red neuronal bueno acá estamos en el colap de la clase 16 como recién mencionábamos dispuestos a programar Nuestra primer red neuronal Aquí vamos a hacer una paralelismo Si se quiere entre nuestra experiencia cuando probábamos algoritmos de regresión lineal simple y nuestra primera Nosotros sabemos siempre que en el caso de Machine learning a un algoritmo le damos valores de x y de y obtenemos con ello Mejor dicho el algoritmo genera un modelo en base a esos datos que le dimos encuentran un patrón generando modelo con lo cual genera una fórmula como esta que está aquí en la cual los valores de x y los valores de y bueno tienen relación con esta expresión matemática es decir cada vez que yo le dé un valor aquí de X lo va a multiplicar por 5 lo va a sumar por dos y va a obtener una y igual a la que yo le di como valor de entrada junto con las x para que genera el modelo bien Esto digamos no estoy diciendo más nuevo digamos es lo que ustedes han visto durante el primer módulo de Machine learning pero ahora la idea Cuál es Es que ustedes puedan comprobar que una red neuronal muy sencilla Nuestra primer red neuronal va a generar un proceso similar y va a obtener los mismos resultados que este algoritmo de regresión lineal simple aquí la diferencia es que esta fórmula la conocemos desde el vamos porque de hecho nos va a permitir justamente generar los valores de X e y quedamos a utilizar para generar bueno Nuestra primer red neuronal vamos a empezar Entonces por importar las librerías como siempre y aquí aparece Bueno un actor importante que vamos a ver o vamos a utilizar de ahora en más así como fue sidekick learn para Machine learning tensorflow es una librería muy importante de las más importantes del mundo de Deep learning también vamos a sumar a nampai y vamos a sumar también aqueras es una Api de tensorflow que nos propone una forma más sencilla de manejar las redes neuronales al menos en esta instancia que estamos empezando a programarlas Cuál es la situación tiene una estructura que por ahí puede ser un poco compleja para quienes empiezan a programar este tipo de algoritmos por lo tanto quieras es una Api que se desprende de tercio Flow tiene propósitos similares De hecho están íntimamente ligadas solamente que tiene herramientas más amigables para quien empieza a programar redes neuronales así que bueno explicado esto vamos a empezar a generar nuestro primer modelo Antes que nada es importante que Bueno les marque que en los libros de trabajo que vamos a traer en cola vamos a poner bastantes explicaciones de cada una de las etapas que vamos llevando adelante y bueno los porqués los conceptos Más allá de que bueno obviamente muchas de estas cosas han sido abordadas en las clases teóricas Bueno poco a poco vamos a ir bueno ampliando o consolidando todos estos conceptos que vimos en las primeras clases y lo vamos a ir poniendo en los comentarios de los notebooks esto no lo habíamos usado tanto en la primer parte de este curso pero visto que ahora vamos a ir un mundo un poquito más complicado un poco más complejo Bueno vamos a ir este bueno utilizando este método para que más allá de la explicación teórica que yo dé en la clase y ustedes puedan repasar viendo Este vídeo Tantas veces como quiera Bueno también tengan este apoyo en el marco del mismo Notebook así que bueno vamos entonces a crear nuestro primer modelo como decíamos recién y nuestro el modelo va a ser el tipo secuencial esto qué quiere decir que va a ser o va a estar preparado para ser formado por una secuencia de capas en este caso lo hacemos a través de secuencias de keras y queras de tensorflow y creamos un modelo que le hemos puesto un móvil Como tantas veces lo hemos hecho sabiendo que Puedo ponerle el nombre que yo quiera que le informo digamos aquí a esta creación de este modelo a través de este método secuencial bueno en principio que va a ser una estructura o una red tipo densa sí es decir aquí llamamos densa sí lo importante bueno básicamente las redes cuando tienen muchas capas formadas por muchas neuronas tienen que estar todas conectadas con todas y esa conexión múltiple digamos esa full conexión se llama o se reconoce como una red de tipo Dance bien y esta red de tipo densa Cuántas capas va a tener una como dice aquí y Cuántas neuronas va a tener esa única capa también una es decir que esto se reduce básicamente a un escenario parecido al que teníamos cuando arrancamos la clase teórica con un perceptrón bien obviamente esto tiene que ver con con hacer una primera red y hacerla de la manera más simple posible para después ir bueno complejizando los ejemplos bien creado Este modelo lo que tenemos que hacer a continuación es compilar nuestra red a través de compay sobre model porque insisto le pusimos a nuestro modelo móvil en el compay vamos a manejar tres hiper parámetros y esto nos va a traer justamente a recordar a conceptos que vimos en las clases teóricas el primero es el del optimizador recuerden todo lo que hablamos del algoritmo del descenso del gradiente que justamente nos permitía ir poco a poco optimizando los pesos y los sesgos de cada una de las neuronas para ir obteniendo una mejor función de coste una menor valor de función de coste en este caso justamente el optimizador que estamos eligiendo es el del descenso del gradiente solamente que en este caso se llama descenso de gradiente estocástico O sea no hay un solo una sola forma de algoritmo de descenso de gradiente este es uno de ellos luego lo que se especifica es la función de pérdida que es la función de pérdida lo que hablamos recién como función de coste Exactamente lo mismo aquí justamente se llama función de pérdida atiende lo mismo tenemos que buscar la menor función de pérdida y se especifica con este hiper parámetro de nombre los qué es lo que pongo en los bien para medir la función de coste o de pérdida no hay una sola forma también hay muchos métodos como recién mencionábamos tipos de optimizadores nosotros elegimos aquí este mini Square error que justamente es lo que dice aquí en la explicación método error cuadrado medio bien y finalmente con metrix especificamos que necesitamos que vaya dándonos referencia de la cura si decir el nivel de precisión que se va obteniendo paso a paso en el entrenamiento ahora vamos a crear dos array con todos los conjuntos de valores para x y para y tomando como referencia la función que ya dijimos hoy y = 5x + 2 por ejemplo de esta manera si x fuese menos 1 y sería menos 3 y así sucesivamente buscando otros valores que en este caso vamos a tomar nada más que seis valores los arrays están aquí Este es el array de las x y este es el array de ahora viene el entrenamiento del modelo fíjense que es exactamente el mismo método que usábamos en Machine learning fit ponemos las x las y el parámetro hipoch sí que esto sí es un concepto nuevo que lo que refiere es la cantidad de entrenamientos que quiero que haga este algoritmo para generar el mejor modelo posible buscando Qué cosas Bueno las dos cosas que aquí estamos poniendo en principio mejorar la precisión a través del optimizador del descenso del gradiente estocástico y bajando la función de pérdida o los fucsia vamos a entrenar el modelo y lo vamos a hacer Online para que ustedes puedan ver justamente Cómo se va mostrando la información que recién referencia vamos bueno y rápidamente me voy para abajo porque lo hace bastante rápido dado que es un modelo muy sencillo fíjense que me va mostrando el entrenamiento número de tanto de tanto sí 455 4 No ya terminó rápidamente no este me voy un poquito para arriba y fíjense que me va diciendo 488 de 500 487 500 y así desde el 1 de 500 Así que como empezó todo esto voy a ubicar bien aquí vamos a ir hasta arriba de todo bien aquí estamos en el primero fíjense la función de pérdida 161.0618 era que iba así en cero yo me voy a ir ahora hacia abajo y van a ver que la función de pérdida Ven aquí ya cambio bajó a 126 luego 99 luego 78 luego 71 luego 48 y va a seguir así bajando qué es lo que estoy buscando justamente que como el optimizador va generando mejores valores de pesos y sesgos la función de pérdida tiene que ir bajando hasta llegar Bueno a la mínima expresión posible si la idea que fuera cero Pero bueno este Esto va a llegar si nos vamos hacia abajo Buscando el entrenamiento 500 de 500 que sería el último de todo al valor 2.36 por 10 a la menos 6 bien se entendió O sea la función bajó desde aquel valor Al toque mencionamos al principio a este pero fíjense la quiura si está en cero o sea nunca tuvo un valor voy a subir un poquito aquí siempre fue cero por qué pasó eso bueno él aquí ahora sí va a funcionar siempre y cuando yo tenga un conjunto de entrenamiento en conjunto de tres aquí como no tengo conjunto de entrenamiento ni conjunto de Test porque solamente es un conjunto de seis valores de X ese valores de Y bueno pues entonces no hay altura así no hay problema ya en el próximo ejemplo que vamos a hacer vamos a tener los dos conjuntos y vamos a poder ver cómo así como va bajando la función de pérdida va subiendo el nivel de precisión o sea de atura sí finalmente vamos a probar el modelo y lo vamos a hacer justamente a través de predic que ya lo hemos usado mucho en Machine learning de el modelo que tenemos puesto model y vamos a imprimirlo dándole a predique el valor 10 con lo cual esto fácilmente podemos predecir Cuál va a ser el resultado el resultado como decimos aquí en las conclusiones finales debería terminar 152 y en realidad fue 52.00449 por qué pasó esto Bueno en realidad Nosotros le hemos dado en principio nada más que seis valores si para generar modelo lo cual obviamente es extremadamente escaso por eso el modelo no está tan seguro ni se afirma en que la fórmula sea igual a 5x + 2 por eso lo hace de una manera muy aproximada casi exactamente el valor 52 que debería haber sido pero justamente con un margen mínimo de error porque porque justamente esa muestra es muy pobre y demasiado bien se las Ha para generar un modelo bastante cercano a la realidad pero evidentemente no va a ser 52 sin decimales O sea la presión entera Como debería haber sido si yo hubiese usado esta fórmula concretamente bien hasta aquí llegamos con esta primer parte de esta clase la idea era generar un modelo muy sencillo para que recorramos todos los componentes y los pasos que hacen a la conformación de una red neuronal artificial conterson Flow y con keras de ahora más vamos a empezar como ustedes ya imaginarán a complejizar la situación y ya por lo pronto en la próxima parte de esta clase vamos a ir un modelo un poquito más complejo y más parecido a lo que nos va a tocar en la realidad de las próximas clases Bueno nos vemos en la siguiente parte aquí terminamos con la primera parte de esta clase nos vemos en la segunda parte